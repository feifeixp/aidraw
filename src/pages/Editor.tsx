import { useState, useEffect, useReducer, useCallback } from "react";
import { Canvas as FabricCanvas, FabricImage, Rect as FabricRect, FabricText, util } from "fabric";
import { Menu, ChevronLeft, ChevronRight } from "lucide-react";
import { useBeforeUnload, useLocation, useNavigate } from "react-router-dom";
import { EditorCanvas } from "@/components/editor/EditorCanvas";
import { EditorToolbar } from "@/components/editor/EditorToolbar";
import { LeftToolbar } from "@/components/editor/LeftToolbar";
import { PropertiesPanel } from "@/components/editor/PropertiesPanel";
import { TaskQueueDisplay } from "@/components/editor/TaskQueueDisplay";
import { DraftsList } from "@/components/editor/DraftsList";
import { Tutorial } from "@/components/editor/Tutorial";
import { EditorInitialSetup } from "@/components/editor/EditorInitialSetup";
import { Button } from "@/components/ui/button";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { useIsMobile } from "@/hooks/use-mobile";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
interface Task {
  id: string;
  name: string;
  status: "processing" | "completed";
}
type HistoryState = {
  history: string[];
  historyIndex: number;
};
type HistoryAction = {
  type: "SAVE_STATE";
  payload: string;
} | {
  type: "UNDO";
} | {
  type: "REDO";
} | {
  type: "RESET";
  payload: string;
};
const historyReducer = (state: HistoryState, action: HistoryAction): HistoryState => {
  switch (action.type) {
    case "SAVE_STATE":
      {
        const newHistory = state.history.slice(0, state.historyIndex + 1);
        newHistory.push(action.payload);

        // Limit history to 50 states
        if (newHistory.length > 50) {
          return {
            history: newHistory.slice(1),
            historyIndex: state.historyIndex // Stay at same position after removing first
          };
        }
        return {
          history: newHistory,
          historyIndex: newHistory.length - 1
        };
      }
    case "UNDO":
      {
        if (state.historyIndex <= 0) return state;
        return {
          ...state,
          historyIndex: state.historyIndex - 1
        };
      }
    case "REDO":
      {
        if (state.historyIndex >= state.history.length - 1) return state;
        return {
          ...state,
          historyIndex: state.historyIndex + 1
        };
      }
    case "RESET":
      {
        // ÈáçÁΩÆÂéÜÂè≤ËÆ∞ÂΩïÔºåÂè™‰øùÁïôÊñ∞ÁöÑÂàùÂßãÁä∂ÊÄÅ
        return {
          history: [action.payload],
          historyIndex: 0
        };
      }
    default:
      return state;
  }
};
const Editor = () => {
  const [canvas, setCanvas] = useState<FabricCanvas | null>(null);
  const [activeTool, setActiveTool] = useState<string>("select");
  const [zoom, setZoom] = useState<number>(80);
  const [eraserBrushSize, setEraserBrushSize] = useState<number>(20);
  const [{
    history,
    historyIndex
  }, dispatchHistory] = useReducer(historyReducer, {
    history: [],
    historyIndex: -1
  });
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [currentTask, setCurrentTask] = useState<Task | null>(null);
  const [isTaskProcessing, setIsTaskProcessing] = useState(false);
  const [isLeftToolbarCollapsed, setIsLeftToolbarCollapsed] = useState(false);
  const [isPropertiesPanelCollapsed, setIsPropertiesPanelCollapsed] = useState(false);
  const [currentDraftId, setCurrentDraftId] = useState<string | undefined>(undefined);
  const [activeFrameId, setActiveFrameId] = useState<string | null>("1");
  const [storyboardFrameCount, setStoryboardFrameCount] = useState(1);
  const isMobile = useIsMobile();
  const navigate = useNavigate();
  const location = useLocation();

  // È°µÈù¢Á¶ªÂºÄÁ°ÆËÆ§
  const [showExitDialog, setShowExitDialog] = useState(false);
  const [pendingNavigation, setPendingNavigation] = useState<string | null>(null);

  // ÂàùÂßãÂåñËÆæÁΩÆ - ÊØèÊ¨°ËøõÂÖ•ÁºñËæëÂô®ÈÉΩÈúÄË¶ÅÂàùÂßãÂåñ
  const [showInitialSetup, setShowInitialSetup] = useState(true);
  const [defaultStyle, setDefaultStyle] = useState("auto");
  const [frameWidth, setFrameWidth] = useState(1024);
  const [frameHeight, setFrameHeight] = useState(576);
  
  // ÊïôÁ®ãÁä∂ÊÄÅ
  const [showTutorial, setShowTutorial] = useState(false);

  // Âú®ÁªÑ‰ª∂ÊåÇËΩΩÊó∂Ê∏ÖÈô§ÊâÄÊúâÁºìÂ≠ò
  useEffect(() => {
    try {
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith('editor-') || key.startsWith('canvas-') || key === 'editorSetupCompleted')) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(key => localStorage.removeItem(key));
      console.log(`Â∑≤Ê∏ÖÈô§ ${keysToRemove.length} ‰∏™ÁºìÂ≠òÈ°π`);
    } catch (error) {
      console.error("Ê∏ÖÈô§ÁºìÂ≠òÂ§±Ë¥•:", error);
    }
  }, []);

  // ‰øùÂ≠òÁîªÂ∏É‰∏∫JSONÊñá‰ª∂
  const handleSaveToLocal = useCallback(() => {
    if (!canvas) return;
    
    const json = canvas.toJSON();
    const dataStr = JSON.stringify(json, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `storyboard-${new Date().getTime()}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    toast.success("ÁîªÂ∏ÉÂ∑≤‰øùÂ≠òÂà∞Êú¨Âú∞");
  }, [canvas]);

  // ‰øùÂ≠òÂπ∂Á¶ªÂºÄ
  const handleSaveAndExit = useCallback(() => {
    handleSaveToLocal();
    setTimeout(() => {
      if (pendingNavigation === "back") {
        window.history.back();
      } else if (pendingNavigation) {
        navigate(pendingNavigation);
      }
      setPendingNavigation(null);
    }, 300);
  }, [handleSaveToLocal, pendingNavigation, navigate]);

  // Â§ÑÁêÜÂàùÂßãÂåñËÆæÁΩÆÂÆåÊàê
  const handleInitialSetupComplete = useCallback((settings: {
    style: string;
    width: number;
    height: number;
  }) => {
    setDefaultStyle(settings.style);
    setFrameWidth(settings.width);
    setFrameHeight(settings.height);
    setShowInitialSetup(false);
    toast.success(`ÂàùÂßãÂåñÂÆåÊàêÔºö${settings.style === 'auto' ? 'Ëá™Âä®È£éÊ†º' : ''}ÔºåÂàÜÈïúÂ∞∫ÂØ∏ ${settings.width}√ó${settings.height}`);
  }, []);

  // ÊâãÂä®ÊòæÁ§∫ÊïôÁ®ã
  const handleShowTutorial = useCallback(() => {
    setShowTutorial(true);
  }, []);

  // ËØ∑Ê±ÇÊòæÁ§∫ÂàùÂßãÂåñËÆæÁΩÆ
  const handleRequestInitialSetup = useCallback(() => {
    setShowInitialSetup(true);
  }, []);

  // Êã¶Êà™ÊµèËßàÂô®ÂÖ≥Èó≠/Âà∑Êñ∞
  useBeforeUnload(
    useCallback((event) => {
      event.preventDefault();
      return (event.returnValue = "ÊÇ®Á°ÆÂÆöË¶ÅÁ¶ªÂºÄÂêóÔºüÊú™‰øùÂ≠òÁöÑÊõ¥ÊîπÂ∞Ü‰∏¢Â§±„ÄÇ");
    }, [])
  );

  // Êã¶Êà™ÊµèËßàÂô®ÂêéÈÄÄ/ÂâçËøõÊåâÈíÆ
  useEffect(() => {
    const handlePopState = (event: PopStateEvent) => {
      event.preventDefault();
      window.history.pushState(null, "", location.pathname);
      setShowExitDialog(true);
      setPendingNavigation("back");
    };

    // Ê∑ªÂä†‰∏Ä‰∏™ÂéÜÂè≤ËÆ∞ÂΩïÊù°ÁõÆ‰ª•‰æøÊã¶Êà™ÂêéÈÄÄ
    window.history.pushState(null, "", location.pathname);
    window.addEventListener("popstate", handlePopState);

    return () => {
      window.removeEventListener("popstate", handlePopState);
    };
  }, [location.pathname]);

  // Êã¶Êà™ÂØºËà™Ê†èÁÇπÂáªË∑≥ËΩ¨
  useEffect(() => {
    const handleNavigationClick = (event: CustomEvent) => {
      event.preventDefault();
      setShowExitDialog(true);
      setPendingNavigation(event.detail.path);
    };

    window.addEventListener("editor:navigation-blocked" as any, handleNavigationClick);

    return () => {
      window.removeEventListener("editor:navigation-blocked" as any, handleNavigationClick);
    };
  }, []);

  // ÁßªÈô§Ëá™Âä®ÊòæÁ§∫ÊïôÁ®ãÁöÑÈÄªËæë

  // ÁßªÈô§Ëá™Âä®‰øùÂ≠òÂäüËÉΩ - ‰∏çÂÜç‰ΩøÁî®localStorageÁºìÂ≠ò

  // Save canvas state to history (exclude frame elements)
  const saveState = useCallback(() => {
    if (!canvas) return;
    
    // Áõ¥Êé•‰ªéÁîªÂ∏ÉËé∑ÂèñÊâÄÊúâÂØπË±°
    const allObjects = canvas.getObjects();
    
    // ÂÖàÂ∫èÂàóÂåñÊï¥‰∏™ÁîªÂ∏É
    const jsonObj = (canvas as any).toJSON(['data', 'name']);
    
    // ÊâãÂä®ËøáÊª§Âπ∂‰øÆÂ§ç data Â±ûÊÄß
    if (jsonObj.objects && jsonObj.objects.length > 0) {
      const filteredObjects: any[] = [];
      
      jsonObj.objects.forEach((serializedObj: any, index: number) => {
        const canvasObj = allObjects[index];
        
        // Ê£ÄÊü•ÁîªÂ∏ÉÂØπË±°ÊòØÂê¶ÊòØÊ°ÜÊû∂ÂÖÉÁ¥†
        if (canvasObj && !(canvasObj as any).data?.isFrameElement) {
          // üîß ÊâãÂä®‰øÆÂ§ç data Âíå name Â±ûÊÄßÔºàFabric.js v6 Êó†Ê≥ïÊ≠£Á°ÆÂ∫èÂàóÂåñÔºâ
          serializedObj.data = (canvasObj as any).data || {};
          serializedObj.name = (canvasObj as any).name || '';
          
          filteredObjects.push(serializedObj);
        }
      });
      
      jsonObj.objects = filteredObjects;
      
      console.log('[Editor] üíæ ‰øùÂ≠òÁä∂ÊÄÅ:', {
        ÁîªÂ∏ÉÊÄªÂØπË±°: allObjects.length,
        ËøáÊª§ÂêéÂØπË±°: filteredObjects.length,
        Ë¢´ËøáÊª§: allObjects.length - filteredObjects.length
      });
    }
    
    const state = JSON.stringify(jsonObj);
    dispatchHistory({
      type: "SAVE_STATE",
      payload: state
    });
  }, [canvas]);
  const undo = useCallback(async () => {
    if (historyIndex <= 0 || !canvas) return;
    console.log('[Editor] ÊâßË°åÊí§ÈîÄÊìç‰ΩúÔºåÂΩìÂâçÂéÜÂè≤Á¥¢Âºï:', historyIndex);
    
    dispatchHistory({
      type: 'UNDO'
    });
    const previousState = history[historyIndex - 1];
    const parsedState = JSON.parse(previousState);
    console.log('[Editor] ÊÅ¢Â§çÂà∞ÂéÜÂè≤Áä∂ÊÄÅÔºåÁî®Êà∑ÂØπË±°Êï∞Èáè:', parsedState.objects?.length || 0);
    
    // ÈÄöÁü•EditorCanvasÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨Âô®
    window.dispatchEvent(new CustomEvent('beforeCanvasRestore'));
    
    // ‰øùÂ≠òÊâÄÊúâÂàÜÈïúÊ°ÜÊû∂ÂÖÉÁ¥†ÁöÑÂºïÁî®Ôºà‰∏çÈúÄË¶ÅÊ∑±Êã∑Ë¥ùÔºâ
    const frameElements = canvas.getObjects().filter((obj: any) => obj.data?.isFrameElement);
    console.log('[Editor] ÂΩìÂâçÊ°ÜÊû∂ÂÖÉÁ¥†Êï∞Èáè:', frameElements.length);
    
    // Âè™Ê∏ÖÈô§ÈùûÊ°ÜÊû∂ÂÖÉÁ¥†
    const nonFrameObjects = canvas.getObjects().filter((obj: any) => !obj.data?.isFrameElement);
    nonFrameObjects.forEach(obj => canvas.remove(obj));
    console.log('[Editor] Ê∏ÖÈô§Áî®Êà∑ÂØπË±°ÂêéÔºåÁîªÂ∏ÉÂØπË±°Êï∞Èáè:', canvas.getObjects().length);
    
    // ÊâãÂä®Ê∑ªÂä†ÂéÜÂè≤Áä∂ÊÄÅ‰∏≠ÁöÑÁî®Êà∑ÂØπË±°Ôºà‰∏ç‰ΩøÁî®loadFromJSONÈÅøÂÖçÊ∏ÖÁ©∫ÁîªÂ∏ÉÔºâ
    if (parsedState.objects && parsedState.objects.length > 0) {
      const objects = await util.enlivenObjects(parsedState.objects);
      // ÂÜçÊ¨°ËøáÊª§ÔºåÁ°Æ‰øù‰∏ç‰ºöÊ∑ªÂä†‰ªª‰ΩïÊ°ÜÊû∂ÂÖÉÁ¥†
      const frameObjects = objects.filter((obj: any) => obj.data?.isFrameElement);
      const userObjects = objects.filter((obj: any) => !obj.data?.isFrameElement);
      
      console.log('[Editor] ‚ö†Ô∏è ÊÅ¢Â§çÂØπË±°ËØ¶ÁªÜÂàÜÊûê:', {
        ÊÄªÂØπË±°Êï∞: objects.length,
        Ê°ÜÊû∂ÂØπË±°Êï∞: frameObjects.length,
        Áî®Êà∑ÂØπË±°Êï∞: userObjects.length,
        Ê°ÜÊû∂ÂØπË±°ËØ¶ÊÉÖ: frameObjects.map((o: any) => ({
          name: o.name,
          type: o.type,
          objectType: o.data?.objectType
        }))
      });
      
      userObjects.forEach((obj: any) => {
        canvas.add(obj);
      });
    }
    console.log('[Editor] ÊÅ¢Â§çÁî®Êà∑ÂÜÖÂÆπÂêéÔºåÁîªÂ∏ÉÂØπË±°Êï∞Èáè:', canvas.getObjects().length);
    
    // ÈÄöÁü•EditorCanvasÊÅ¢Â§ç‰∫ã‰ª∂ÁõëÂê¨Âô®Âπ∂Êõ¥Êñ∞refs
    window.dispatchEvent(new CustomEvent('canvasStateRestored'));
    
    canvas.renderAll();
    console.log('[Editor] Êí§ÈîÄÊìç‰ΩúÂÆåÊàêÔºåÂΩìÂâçÁîªÂ∏ÉÂØπË±°Êï∞Èáè:', canvas.getObjects().length);
  }, [canvas, historyIndex, history]);
  const redo = useCallback(async () => {
    if (historyIndex >= history.length - 1 || !canvas) return;
    console.log('[Editor] ÊâßË°åÈáçÂÅöÊìç‰ΩúÔºåÂΩìÂâçÂéÜÂè≤Á¥¢Âºï:', historyIndex);
    
    const nextState = history[historyIndex + 1];
    const parsedState = JSON.parse(nextState);
    console.log('[Editor] ÊÅ¢Â§çÂà∞ÂéÜÂè≤Áä∂ÊÄÅÔºåÁî®Êà∑ÂØπË±°Êï∞Èáè:', parsedState.objects?.length || 0);
    dispatchHistory({
      type: 'REDO'
    });
    
    // ÈÄöÁü•EditorCanvasÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨Âô®
    window.dispatchEvent(new CustomEvent('beforeCanvasRestore'));
    
    // ‰øùÂ≠òÊâÄÊúâÂàÜÈïúÊ°ÜÊû∂ÂÖÉÁ¥†ÁöÑÂºïÁî®Ôºà‰∏çÈúÄË¶ÅÊ∑±Êã∑Ë¥ùÔºâ
    const frameElements = canvas.getObjects().filter((obj: any) => obj.data?.isFrameElement);
    console.log('[Editor] ÂΩìÂâçÊ°ÜÊû∂ÂÖÉÁ¥†Êï∞Èáè:', frameElements.length);
    
    // Âè™Ê∏ÖÈô§ÈùûÊ°ÜÊû∂ÂÖÉÁ¥†
    const nonFrameObjects = canvas.getObjects().filter((obj: any) => !obj.data?.isFrameElement);
    nonFrameObjects.forEach(obj => canvas.remove(obj));
    console.log('[Editor] Ê∏ÖÈô§Áî®Êà∑ÂØπË±°ÂêéÔºåÁîªÂ∏ÉÂØπË±°Êï∞Èáè:', canvas.getObjects().length);
    
    // ÊâãÂä®Ê∑ªÂä†ÂéÜÂè≤Áä∂ÊÄÅ‰∏≠ÁöÑÁî®Êà∑ÂØπË±°Ôºà‰∏ç‰ΩøÁî®loadFromJSONÈÅøÂÖçÊ∏ÖÁ©∫ÁîªÂ∏ÉÔºâ
    if (parsedState.objects && parsedState.objects.length > 0) {
      const objects = await util.enlivenObjects(parsedState.objects);
      // ÂÜçÊ¨°ËøáÊª§ÔºåÁ°Æ‰øù‰∏ç‰ºöÊ∑ªÂä†‰ªª‰ΩïÊ°ÜÊû∂ÂÖÉÁ¥†
      const frameObjects = objects.filter((obj: any) => obj.data?.isFrameElement);
      const userObjects = objects.filter((obj: any) => !obj.data?.isFrameElement);
      
      console.log('[Editor] ‚ö†Ô∏è ÊÅ¢Â§çÂØπË±°ËØ¶ÁªÜÂàÜÊûê:', {
        ÊÄªÂØπË±°Êï∞: objects.length,
        Ê°ÜÊû∂ÂØπË±°Êï∞: frameObjects.length,
        Áî®Êà∑ÂØπË±°Êï∞: userObjects.length,
        Ê°ÜÊû∂ÂØπË±°ËØ¶ÊÉÖ: frameObjects.map((o: any) => ({
          name: o.name,
          type: o.type,
          objectType: o.data?.objectType
        }))
      });
      
      userObjects.forEach((obj: any) => {
        canvas.add(obj);
      });
    }
    console.log('[Editor] ÊÅ¢Â§çÁî®Êà∑ÂÜÖÂÆπÂêéÔºåÁîªÂ∏ÉÂØπË±°Êï∞Èáè:', canvas.getObjects().length);
    
    // ÈÄöÁü•EditorCanvasÊÅ¢Â§ç‰∫ã‰ª∂ÁõëÂê¨Âô®Âπ∂Êõ¥Êñ∞refs
    window.dispatchEvent(new CustomEvent('canvasStateRestored'));
    
    canvas.renderAll();
    console.log('[Editor] ÈáçÂÅöÊìç‰ΩúÂÆåÊàêÔºåÂΩìÂâçÁîªÂ∏ÉÂØπË±°Êï∞Èáè:', canvas.getObjects().length);
  }, [canvas, historyIndex, history]);
  const startTask = useCallback((taskName: string) => {
    const taskId = Date.now().toString();
    setCurrentTask({
      id: taskId,
      name: taskName,
      status: "processing"
    });
    setIsTaskProcessing(true);
    return taskId;
  }, []);
  const completeTask = useCallback((taskId: string) => {
    setCurrentTask(prev => prev?.id === taskId ? {
      ...prev,
      status: "completed"
    } : prev);
    setTimeout(() => {
      setCurrentTask(null);
      setIsTaskProcessing(false);
    }, 1500);
  }, []);
  const cancelTask = useCallback(() => {
    setCurrentTask(null);
    setIsTaskProcessing(false);
  }, []);

  // Save initial state when canvas is created
  useEffect(() => {
    if (canvas && history.length === 0) {
      // Small delay to ensure canvas is fully initialized
      const timer = setTimeout(() => {
        const allObjects = canvas.getObjects();
        const jsonObj = (canvas as any).toJSON(['data', 'name']);
        
        // üîß ÊâãÂä®‰øÆÂ§ç data Âíå name Â±ûÊÄßÔºàFabric.js v6 Â∫èÂàóÂåñÈóÆÈ¢òÔºâ
        if (jsonObj.objects && jsonObj.objects.length > 0) {
          jsonObj.objects.forEach((serializedObj: any, index: number) => {
            const canvasObj = allObjects[index];
            if (canvasObj) {
              serializedObj.data = (canvasObj as any).data || {};
              serializedObj.name = (canvasObj as any).name || '';
            }
          });
        }
        
        // ËøáÊª§ÊéâÊ°ÜÊû∂ÂÖÉÁ¥†
        if (jsonObj.objects) {
          jsonObj.objects = jsonObj.objects.filter((obj: any) => !obj.data?.isFrameElement);
        }
        const state = JSON.stringify(jsonObj);
        dispatchHistory({
          type: "SAVE_STATE",
          payload: state
        });
      }, 100);
      return () => clearTimeout(timer);
    }
  }, [canvas, history.length]);

  // ÁßªÈô§Ëá™Âä®Âä†ËΩΩËçâÁ®øÂäüËÉΩ - ‰∏çÂÜç‰ΩøÁî®localStorageÁºìÂ≠ò

  // Keyboard shortcut for pan tool (H key)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Check if user is typing in an input field
      const target = e.target as HTMLElement;
      const isInputField = target.tagName === 'INPUT' || 
                          target.tagName === 'TEXTAREA' || 
                          target.isContentEditable;
      
      if (isInputField) return;
      
      if (e.key === 'h' || e.key === 'H') {
        setActiveTool(prev => prev === "pan" ? "select" : "pan");
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);
  const handleCloseMobileMenu = useCallback(() => {
    setMobileMenuOpen(false);
  }, []);

  // Smart extract function
  const handleSmartExtract = useCallback(async () => {
    const activeObject = canvas?.getActiveObject();
    if (!canvas || !activeObject || activeObject.type !== 'image') {
      return; // Silently return if conditions not met (called automatically)
    }
    
    const taskId = startTask("Ê≠£Âú®Êô∫ËÉΩÊèêÂèñ");
    try {
      // Dynamic import helper functions
      const loadImageFromDataURL = (dataUrl: string): Promise<HTMLImageElement> => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = dataUrl;
        });
      };

      const classifyExtractedObject = async (imageBlob: Blob): Promise<'character' | 'prop' | 'scene'> => {
        try {
          const { supabase } = await import("@/integrations/supabase/client");
          const reader = new FileReader();
          const imageDataUrl = await new Promise<string>((resolve, reject) => {
            reader.onload = () => resolve(reader.result as string);
            reader.onerror = reject;
            reader.readAsDataURL(imageBlob);
          });
          
          const { data, error } = await supabase.functions.invoke('classify-object', {
            body: { imageUrl: imageDataUrl }
          });
          
          if (error) throw error;
          return data.elementType;
        } catch (error) {
          console.error('Classification error:', error);
          return 'prop';
        }
      };

      // Get original image dimensions and calculate multiplier to maintain quality
      const fabricImage = activeObject as any;
      const originalWidth = fabricImage.width;
      const originalHeight = fabricImage.height;
      const scaleX = fabricImage.scaleX || 1;
      const scaleY = fabricImage.scaleY || 1;
      
      // Calculate multiplier to export at original resolution
      const multiplier = 1 / Math.min(scaleX, scaleY);
      
      // Convert image to data URL at original resolution
      const imageDataURL = fabricImage.toDataURL({
        format: 'png',
        quality: 1,
        multiplier: multiplier,
        enableRetinaScaling: false
      });
      
      // Load image
      const img = await loadImageFromDataURL(imageDataURL);
      
      // Initialize MediaPipe segmenter
      const { MediaPipeSegmenter } = await import("@/lib/mediapipe/interactiveSegmenter");
      const segmenter = new MediaPipeSegmenter();
      await segmenter.initialize();
      
      // Use center point for segmentation
      const centerX = img.width / 2;
      const centerY = img.height / 2;
      
      const result = await segmenter.segmentWithPoint(img, centerX, centerY);
      
      if (!result || !result.categoryMask) {
        toast.info("Êú™Ê£ÄÊµãÂà∞ÈúÄË¶ÅÊèêÂèñÁöÑÁâ©‰Ωì");
        cancelTask();
        segmenter.close();
        return;
      }
      
      // Create source canvas
      const sourceCanvas = document.createElement('canvas');
      sourceCanvas.width = img.width;
      sourceCanvas.height = img.height;
      const ctx = sourceCanvas.getContext('2d')!;
      ctx.drawImage(img, 0, 0);
      
      // Extract the masked object with dilation and feathering (auto-extract uses defaults)
      const maskData = result.categoryMask.getAsUint8Array();
      const extractedCanvas = segmenter.extractMaskedImage(
        sourceCanvas,
        maskData,
        result.categoryMask.width,
        result.categoryMask.height,
        {
          dilation: -2,  // ËæπÁºòÊî∂Áº©ÔºöË¥üÊï∞ÂêëÂÜÖÊî∂Áº©ÔºåÊ≠£Êï∞ÂêëÂ§ñÊâ©Âº†Ôºå0 = ‰∏çÂèò
          feather: 0,    // ËæπÁºòÁæΩÂåñÔºö0 = Á°¨ËæπÁºò
          padding: 10,   // Ë£ÅÂâ™ËæπË∑ùÔºö10ÂÉèÁ¥†ÔºàÂáèÂ∞èËøô‰∏™ÂÄºÂèØ‰ª•ËÆ©Ë£ÅÂâ™Êõ¥Á¥ßÂáëÔºâ
          crop: true     // ÂêØÁî®Êô∫ËÉΩË£ÅÂâ™
        }
      );
      
      // Convert to blob for classification
      const blob = await new Promise<Blob>((resolve, reject) => {
        extractedCanvas.toBlob(
          (b) => b ? resolve(b) : reject(new Error('Failed to create blob')),
          'image/png'
        );
      });
      
      // Classify the object
      const elementType = await classifyExtractedObject(blob);
      
      // Convert extracted canvas to data URL
      const extractedDataURL = extractedCanvas.toDataURL('image/png');
      
      // Create new fabric image
      const newImg = await FabricImage.fromURL(extractedDataURL, {
        crossOrigin: 'anonymous'
      });
      
      newImg.set({
        left: activeObject.left,
        top: activeObject.top,
        scaleX: activeObject.scaleX,
        scaleY: activeObject.scaleY,
        data: {
          ...(activeObject as any).data,
          elementType: elementType
        }
      });
      
      canvas.remove(activeObject);
      
      // Insert at correct layer position
      const { insertObjectWithLayerType } = await import("@/lib/layerSorting");
      insertObjectWithLayerType(canvas, newImg, elementType);
      
      canvas.setActiveObject(newImg);
      canvas.renderAll();
      saveState();
      
      segmenter.close();
      completeTask(taskId);
      toast.success(`Â∑≤Ëá™Âä®ÊèêÂèñÁâ©‰Ωì (${elementType})`);
    } catch (error) {
      console.error("Smart extract error:", error);
      toast.error("Êô∫ËÉΩÊèêÂèñÂ§±Ë¥•");
      cancelTask();
    }
  }, [canvas, saveState, startTask, completeTask, cancelTask]);

  const handleLoadDraft = useCallback(async (draftData: string) => {
    if (!canvas) return;
    try {
      const parsedData = JSON.parse(draftData);
      
      // Ê∏ÖÁ©∫Êï¥‰∏™ÁîªÂ∏ÉÔºàÂåÖÊã¨ÂàÜÈïúÔºâ
      canvas.clear();
      
      // Âä†ËΩΩËçâÁ®øÊï∞ÊçÆÔºàÂåÖÂê´ÊâÄÊúâÂÜÖÂÆπÔºåÂåÖÊã¨ÂàÜÈïúÔºâ
      await canvas.loadFromJSON(parsedData);
      canvas.renderAll();
      
      // ÈáçÁΩÆÂéÜÂè≤ËÆ∞ÂΩïÔºà‰ªÖ‰øùÂ≠òÁî®Êà∑ÂÜÖÂÆπÔºå‰∏çÂåÖÂê´Ê°ÜÊû∂ÂÖÉÁ¥†Ôºâ
      const allObjects = canvas.getObjects();
      const jsonObj = (canvas as any).toJSON(['data', 'name']);
      
      // üîß ÊâãÂä®‰øÆÂ§ç data Âíå name Â±ûÊÄßÔºàFabric.js v6 Â∫èÂàóÂåñÈóÆÈ¢òÔºâ
      if (jsonObj.objects && jsonObj.objects.length > 0) {
        jsonObj.objects.forEach((serializedObj: any, index: number) => {
          const canvasObj = allObjects[index];
          if (canvasObj) {
            serializedObj.data = (canvasObj as any).data || {};
            serializedObj.name = (canvasObj as any).name || '';
          }
        });
      }
      
      if (jsonObj.objects) {
        jsonObj.objects = jsonObj.objects.filter((obj: any) => !obj.data?.isFrameElement);
      }
      const state = JSON.stringify(jsonObj);
      dispatchHistory({ type: 'RESET', payload: state });
      
      toast.success("ËçâÁ®øÂ∑≤Âä†ËΩΩ");
    } catch (error) {
      console.error("Âä†ËΩΩËçâÁ®øÂ§±Ë¥•:", error);
      toast.error("Âä†ËΩΩËçâÁ®øÂ§±Ë¥•");
    }
  }, [canvas]);
  const leftToolbarContent = (
    <div className="overflow-auto h-full">
      <LeftToolbar 
        canvas={canvas} 
        saveState={saveState} 
        isTaskProcessing={isTaskProcessing} 
        startTask={startTask} 
        completeTask={completeTask} 
        cancelTask={cancelTask} 
        onActionComplete={isMobile ? handleCloseMobileMenu : undefined}
        isCollapsed={isLeftToolbarCollapsed}
        onToggleCollapse={() => setIsLeftToolbarCollapsed(!isLeftToolbarCollapsed)}
        onSmartExtract={handleSmartExtract}
        activeTool={activeTool}
        setActiveTool={setActiveTool}
        eraserBrushSize={eraserBrushSize}
        setEraserBrushSize={setEraserBrushSize}
        activeFrameId={activeFrameId}
      />
    </div>
  );
  return <div className="h-screen w-full bg-background flex flex-col">
      {showInitialSetup && (
        <EditorInitialSetup
          open={showInitialSetup}
          onComplete={handleInitialSetupComplete}
        />
      )}
      {showTutorial && <Tutorial onComplete={() => setShowTutorial(false)} />}
      <TaskQueueDisplay currentTask={currentTask} />
      
      {/* Á¶ªÂºÄÁ°ÆËÆ§ÂØπËØùÊ°Ü */}
      <AlertDialog open={showExitDialog} onOpenChange={setShowExitDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Á°ÆËÆ§Á¶ªÂºÄÔºü</AlertDialogTitle>
            <AlertDialogDescription>
              ÊÇ®Á°ÆÂÆöË¶ÅÁ¶ªÂºÄÁºñËæëÂô®ÂêóÔºüËØ∑Á°Æ‰øùÂ∑≤‰øùÂ≠òÊÇ®ÁöÑÂ∑•‰ΩúÂà∞ËçâÁ®ø„ÄÇ
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter className="flex-col sm:flex-row gap-2">
            <AlertDialogCancel
              onClick={() => {
                setPendingNavigation(null);
              }}
            >
              ÂèñÊ∂à
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleSaveAndExit}
              className="bg-primary hover:bg-primary/90"
            >
              ‰øùÂ≠òÂπ∂Á¶ªÂºÄ
            </AlertDialogAction>
            <AlertDialogAction
              onClick={() => {
                if (pendingNavigation === "back") {
                  window.history.back();
                } else if (pendingNavigation) {
                  navigate(pendingNavigation);
                }
                setPendingNavigation(null);
              }}
              className="bg-destructive hover:bg-destructive/90"
            >
              Áõ¥Êé•Á¶ªÂºÄ
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
      <div className="border-b border-border p-2 flex items-center gap-2 my-[20px] overflow-x-auto editor-toolbar">
        {isMobile && <Sheet open={mobileMenuOpen} onOpenChange={setMobileMenuOpen}>
            <SheetTrigger asChild>
              <Button variant="outline" size="icon" className="shrink-0">
                <Menu className="h-4 w-4" />
              </Button>
            </SheetTrigger>
            <SheetContent side="left" className="w-64 p-0 flex flex-col">
              {leftToolbarContent}
            </SheetContent>
          </Sheet>}
        <div className="drafts-list">
          <DraftsList 
            canvas={canvas} 
            onLoadDraft={handleLoadDraft}
            currentDraftId={currentDraftId}
            onDraftIdChange={setCurrentDraftId}
            onActiveFrameIdChange={setActiveFrameId}
            onFrameCountChange={setStoryboardFrameCount}
            onRequestInitialSetup={handleRequestInitialSetup}
          />
        </div>
        <div className="flex-1 min-w-0 overflow-x-auto">
          <EditorToolbar
            canvas={canvas} 
            activeTool={activeTool} 
            setActiveTool={setActiveTool} 
            undo={undo} 
            redo={redo} 
            canUndo={historyIndex > 0} 
            canRedo={historyIndex < history.length - 1} 
            saveState={saveState} 
            isTaskProcessing={isTaskProcessing} 
            startTask={startTask} 
            completeTask={completeTask} 
            cancelTask={cancelTask}
            zoom={zoom}
            onZoomChange={setZoom}
            activeFrameId={activeFrameId}
            onActiveFrameChange={setActiveFrameId}
            storyboardFrameCount={storyboardFrameCount}
            setStoryboardFrameCount={setStoryboardFrameCount}
            defaultStyle={defaultStyle}
            defaultFrameWidth={frameWidth}
            defaultFrameHeight={frameHeight}
            onShowTutorial={handleShowTutorial}
          />
        </div>
      </div>
      
      <div className="flex-1 relative overflow-hidden editor-canvas flex">
        <EditorCanvas 
          canvas={canvas} 
          setCanvas={setCanvas} 
          activeTool={activeTool} 
          saveState={saveState}
          zoom={zoom}
          onZoomChange={setZoom}
          eraserBrushSize={eraserBrushSize}
          activeFrameId={activeFrameId}
          onActiveFrameChange={setActiveFrameId}
          defaultFrameWidth={frameWidth}
          defaultFrameHeight={frameHeight}
        />
        {!isMobile && (
          <div className={`absolute left-4 top-4 ${isLeftToolbarCollapsed ? 'w-16' : 'w-48'} h-[calc(100%-2rem)] flex flex-col bg-background/95 backdrop-blur-sm border border-border rounded-lg shadow-lg z-10 overflow-hidden transition-all duration-300 left-toolbar`}>
            {leftToolbarContent}
          </div>
        )}
        
        {/* Right Properties Panel */}
        {!isMobile && !isPropertiesPanelCollapsed && (
          <div className="absolute right-4 top-4 w-80 h-[calc(100%-2rem)] flex flex-col bg-background/95 backdrop-blur-sm border border-border rounded-lg shadow-lg z-10 overflow-hidden">
            <div className="flex items-center justify-between p-3 border-b border-border">
              <h3 className="font-medium">Â±ûÊÄßÈù¢Êùø</h3>
              <Button 
                variant="ghost" 
                size="icon" 
                onClick={() => setIsPropertiesPanelCollapsed(true)}
                className="h-8 w-8"
              >
                <ChevronRight className="h-4 w-4" />
              </Button>
            </div>
            <div className="flex-1 overflow-auto p-4">
              <PropertiesPanel 
                canvas={canvas} 
                saveState={saveState}
                isTaskProcessing={isTaskProcessing}
                startTask={startTask}
                completeTask={completeTask}
                cancelTask={cancelTask}
                onSmartExtract={handleSmartExtract}
              />
            </div>
          </div>
        )}
        
        {/* Collapsed Properties Panel Toggle */}
        {!isMobile && isPropertiesPanelCollapsed && (
          <Button
            variant="outline"
            size="icon"
            onClick={() => setIsPropertiesPanelCollapsed(false)}
            className="absolute right-4 top-4 z-10 bg-background/95 backdrop-blur-sm"
            title="ÊòæÁ§∫Â±ûÊÄßÈù¢Êùø"
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>
        )}
      </div>
    </div>;
};
export default Editor;